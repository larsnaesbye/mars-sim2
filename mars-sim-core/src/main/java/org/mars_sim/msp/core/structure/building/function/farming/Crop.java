/*
 * Mars Simulation Project
 * Crop.java
 * @date 2021-10-21
 * @author Scott Davis
 */
package org.mars_sim.msp.core.structure.building.function.farming;

import java.io.Serializable;
import java.util.Arrays;
import java.util.logging.Level;

import org.mars_sim.msp.core.logging.SimLogger;
import org.mars_sim.msp.core.person.Person;
import org.mars_sim.msp.core.person.ai.task.utils.Worker;
import org.mars_sim.msp.core.resource.ItemResourceUtil;
import org.mars_sim.msp.core.resource.ResourceUtil;
import org.mars_sim.msp.core.structure.building.Building;
import org.mars_sim.msp.core.time.ClockPulse;
import org.mars_sim.msp.core.time.MarsClock;
import org.mars_sim.msp.core.time.MasterClock;
import org.mars_sim.msp.core.tool.RandomUtil;

/**
 * The Crop class describes the behavior of a crop growing on a greenhouse.
 */
public class Crop implements Comparable<Crop>, Serializable {

	/** default serial id. */
	private static final long serialVersionUID = 1L;
	/** default logger. */
	private static SimLogger logger = SimLogger.getLogger(Crop.class.getName());

	private static final double TUNING_FACTOR = 0.2;
	
	private static final int CHECK_HEALTH_FREQUENCY = 20;
	/**
	 * The limiting factor that determines how fast and how much PAR can be absorbed
	 * in one frame.
	 */
	private static final double PHYSIOLOGICAL_LIMIT = 0.9; // 1 is max. if set to 1, a lot of lights will toggle on and
															// off undesirably.
	private static final double RATIO_LEAVES = .75;
	
	/** The average amount of new soil needed needed per square meters. */
	public static final double NEW_SOIL_NEEDED_PER_SQM = .2D;
	/**
	 * The average amount of fertilizers needed when watering (but not needed if
	 * supplied with grey water).
	 */
	public static final double FERTILIZER_NEEDED_WATERING = 0.00005D; // a very minute amount needed per unit time,
																		// called if grey water is not available
	/**
	 * The average amount of fertilizers needed per square meter when planting a new
	 * crop.
	 */
	public static final double FERTILIZER_NEEDED_IN_SOIL_PER_SQM = 1D;

	/**
	 * The ratio of oxygen to carbon during the day when photosynthesis is taking
	 * place and CO2 is absorbed and O2 is generated by the crop.
	 */
	private static final double O2_TO_CO2_RATIO = 44 / 32D;
	/**
	 * The rate of carbon dioxide to oxygen during night time when O2 is absorbed
	 * and CO2 is released by the crop.
	 */
	private static final double CO2_TO_O2_RATIO = 32 / 44D; // 6 CO2 --> 6 O2
	// 6nCO2+5nH2Oâ‡’(C6H10O5)n+6nO2

	// public static final double SOLAR_IRRADIANCE_TO_PAR_RATIO = .42; // only 42%
	// are EM within 400 to 700 nm
	// see
	// http://ccar.colorado.edu/asen5050/projects/projects_2001/benoit/solar_irradiance_on_mars.htm#_top
	// public static final double WATT_TO_PHOTON_CONVERSION_RATIO = 4.609; // in u
	// mol / m2 /s / W m-2 for Mars only

	/** The wattage of a 400W high pressure sodium (HPS) lamp. */
	private static final double KW_PER_HPS = .4;
	/** The lamp efficiency of the high pressure sodium (HPS) lamp. */
	private static final double VISIBLE_RADIATION_HPS = 0.4;
	/** The ballast loss of the high pressure sodium (HPS) lamp. */
	private static final double BALLAST_LOSS_HPS = 0.1;
	/** The non-visible radiation loss of the high pressure sodium (HPS) lamp. */
	private static final double NON_VISIBLE_RADIATION_HPS = .37;
	/** The conduction convection loss of the high pressure sodium (HPS) lamp. */
	private static final double CONDUCTION_CONVECTION_HPS = .13;
	/** The total loss of the high pressure sodium (HPS) lamp. */
	public static final double LOSS_FACTOR_HPS = NON_VISIBLE_RADIATION_HPS * .75 + CONDUCTION_CONVECTION_HPS / 2D;
	/** The minimal amount of resource to be retrieved. */
	private static final double MIN = 0.00001;
	/** The string reference for mushroom */	
	private static final String MUSHROOM = "mushroom";
	
	// public static final double MEAN_DAILY_PAR = 237.2217D ; // in [mol/m2/day]
	// SurfaceFeatures.MEAN_SOLAR_IRRADIANCE * 4.56 * (not 88775.244)/1e6 = 237.2217

	// Data members
	/** The crop identifier (unique only within a greenhouse). */
	private int identifier;
	/** True if this crop is generated at the start of the sim . */
	private boolean isStartup;

	/** True if this crop is a seeded plant. e.g. the sesame plant */
	//private boolean isSeedPlant = false;
	/** The total amount of light received by this crop. */	
	private double effectivePAR;
	/** The ratio between inedible and edible biomass */
	private double massRatio;
	/** The maximum possible harvest for this crop [in kg]. */
	private double maxHarvest;
	/** The remaining possible harvest for this crop [in kg]. */
	private double remainingHarvest;
	/** The completed work time in current phase [in millisols]. */
	private double currentPhaseWorkCompleted = 0;
	/** The daily harvest for crop [in kg/per sol]. */
	private double dailyHarvest;
	/** The total amount harvested [in kg]. */
	private double totalHarvest;
	/** The growing phase time completed thus far [in millisols]. */
	private double growingTimeCompleted;
	/** Percentage of growing completed */
	private double percentageGrowth;
	/** The area occupied by the crop in square meters. */
	private double growingArea;
	/** The cumulative value of the daily PAR so far. */
	private double cumulativeDailyPAR = 0;
	/** The required power for lighting [in kW]. */
	private double lightingPower = 0;
	/** The health condition factor of the crop. 1 = excellent. 0 = worst*/
	private double healthCondition = 1;
	/** The average water needed [in kg] */
	private double averageWaterNeeded;
	/** The average O2 needed [in kg] */
	private double averageOxygenNeeded;
	/** The average CO2 needed [in kg] */
	private double averageCarbonDioxideNeeded;
	/**
	 * The watt to photon conversion ratio on Mars as defined in crops.xml [in umol
	 * /m^2 /s /(Wm^-2)].
	 */
	private double wattToPhotonConversionRatio;
	/**
	 * The converted value of the watt to photon conversion ratio on Mars as defined
	 * in crops.xml [in umol /m^2 /millisols /(Wm^-2)].
	 */
	private double conversion_factor;
	/** The disease index of a crop */
	private double diseaseIndex = 0;

	private double cumulative_water_usage = 0;

	private double cumulative_o2 = 0;

	private double cumulative_co2 = 0;
	
	private double co2Cache = 0;
	
	private final double co2Threshold;
	
	private double o2Cache = 0;
	
	private final double o2Threshold;
	
	private final static int LIGHT_FACTOR = 0;
	private final static int FERTILIZER_FACTOR = 1;
	private final static int TEMPERATURE_FACTOR = 2;
	private final static int WATER_FACTOR = 3;
	private final static int O2_FACTOR = 4;
	private final static int CO2_FACTOR = 5;
	
	/** The cache values of the pastor environment factors influencing the crop */
	private double[] environmentalFactor = new double[CO2_FACTOR+1];

	private CropSpec cropSpec;

	/** Current phase of crop. */
	private PhaseType phaseType;

	private Farming farm;
	private Building building;

	private final static int WATER_ID = ResourceUtil.waterID;
	private final static int OXYGEN_ID = ResourceUtil.oxygenID;
	private final static int CO2_ID = ResourceUtil.co2ID;
	private final static int GREY_WATER_ID = ResourceUtil.greyWaterID;
	private final static int CROP_WASTE_ID = ResourceUtil.cropWasteID;
	private final static int FERTILIZER_ID = ResourceUtil.fertilizerID;
	
	private final static int MUSHROOM_BOX_ID = ItemResourceUtil.mushroomBoxID;

	private static CropConfig cropConfig;
	

	/**
	 * Constructor.
	 * 
	 * @param identifier      the identifier of this crop.
	 * @param cropType        the type of crop.
	 * @param growingArea     the area occupied by the crop [m^2]
	 * @param dailyMaxHarvest - Maximum possible food harvest for crop. (kg/sol)
	 * @param farm            - Farm crop being grown in.
	 * @param isStartup       - true if this crop is generated at the start of the
	 *                        sim)
	 * @param tissuePercent   the percentage of ticarbonDioxideIDure available based
	 *                        on the requested amount
	 */
	public Crop(int identifier, CropSpec cropType, double growingArea, double dailyMaxHarvest, Farming farm, 
			boolean isStartup, double tissuePercent) {

		this.identifier = identifier;
		this.cropSpec = cropType;
		this.growingArea = growingArea;
		this.farm = farm;
		this.isStartup = isStartup;
		this.co2Threshold = growingArea/10.0;
		this.o2Threshold = growingArea/10.0;

		// Set up env factor to be balanced
		Arrays.fill(environmentalFactor, 1D);
		
		building = farm.getBuilding();

		// Note : growingTime is in millisols
		double growingTime = cropType.getGrowingTime();
		// Note : growingDay in sols
		double growingDay = growingTime / 1000D;
		
		maxHarvest = dailyMaxHarvest * growingDay;
		// Set to zero initially
		remainingHarvest = 0;

		if (cropSpec.getSeedID() > 0) {
			massRatio = 1;
		}

		averageWaterNeeded = cropConfig.getWaterConsumptionRate();
		averageOxygenNeeded = cropConfig.getOxygenConsumptionRate();
		averageCarbonDioxideNeeded = cropConfig.getCarbonDioxideConsumptionRate();
		wattToPhotonConversionRatio = cropConfig.getWattToPhotonConversionRatio();

		conversion_factor = 1000D * wattToPhotonConversionRatio / MarsClock.SECONDS_PER_MILLISOL;

		if (!isStartup) {
			// if this is not a grown crop at the start of the sim, start from the beginning

			if (tissuePercent <= 0) {
				// assume a max 2-day incubation period if no 0% tissue culture is available
				currentPhaseWorkCompleted = 0;
				phaseType = PhaseType.INCUBATION;
				logger.log(building, Level.INFO, 0, " No " + cropSpec.getName() 
						+ " tissue-culture left. Restocking.");
			}

			else if (tissuePercent >= 100) {
				// assume zero day incubation period if 100% tissue culture is available
				currentPhaseWorkCompleted = 0;
				phaseType = PhaseType.PLANTING;
				logger.log(building, Level.INFO, 0, "Done growing " + cropSpec.getName()
						+ "'s tissue-culture. Transferring plantflets to the field.");
				// if it's growing mushroom
				setupMushroom();
			}

			else {
				phaseType = PhaseType.INCUBATION;
				currentPhaseWorkCompleted = 1000D * cropSpec.getPhase(phaseType).getWorkRequired() * (100D - tissuePercent) / 100D;
				logger.log(building, Level.INFO, 0, "A work period of "
								+ Math.round(currentPhaseWorkCompleted / 1000D * 10D) / 10D
								+ " sols is needed to clone enough " + cropSpec.getName() + " tissues before planting.");
			}

		}

		else {
			// This is a grown crop at the start of the sim,
			// Set the percentage of growth randomly
			growingTimeCompleted = RandomUtil.getRandomDouble(growingTime * .95); // for testing only :
																					// growingTimeCompleted =
																					// growingTime - 3000 +
																					// RandomUtil.getRandomDouble(3000D);
																					// or = growingTime * .975;

			percentageGrowth = (growingTimeCompleted * 100D) / growingTime;
			
			// Fast track through the phases
			phaseType = PhaseType.INCUBATION;
			while (percentageGrowth > cropSpec.getNextPhasePercentage(phaseType)) {
				phaseType = cropSpec.getNextPhaseType(phaseType);
			}

			// Set the daily harvest
			dailyHarvest = dailyMaxHarvest;
			// Set the remaining harvest based on the fractional growth
			remainingHarvest = (maxHarvest * percentageGrowth)/100D;
		}

	}

	private void setupMushroom() {
		if (cropSpec.getName().toLowerCase().contains(MUSHROOM)) {
			
			if (building.getSettlement().hasItemResource(MUSHROOM_BOX_ID)) {
				building.getSettlement().retrieveItemResource(MUSHROOM_BOX_ID, 1);
			}
			// Require some dead matter for fungi to decompose
			if (growingArea * .5 > MIN)
				retrieve(growingArea * .5, CROP_WASTE_ID, true);
		}
	}

	public double getLightingPower() {
		return lightingPower;
	}

	public double getGrowingArea() {
		return growingArea;
	}

	/**
	 * Gets the crop type that defines this Crop
	 *
	 * @return crop type ID
	 */
	public CropSpec getCropType() {
		return cropSpec;
	}

	/**
	 * Gets the crop name
	 * 
	 * @return crop name
	 */
	public String getCropName() {
		return cropSpec.getName();
	}
	
	/**
	 * Gets the phase type of the crop.
	 * 
	 * @return phaseType
	 */
	public PhaseType getPhaseType() {
		return phaseType;
	}


	/**
	 * Gets the maximum possible food harvest for crop.
	 * 
	 * @return food harvest (kg.)
	 */
	public double getMaxHarvest() {
		return maxHarvest;
	}

	/**
	 * Gets the amount of growing time completed.
	 * 
	 * @return growing time (millisols)
	 */
	public double getGrowingTimeCompleted() {
		return growingTimeCompleted;
	}

	/**
	 * Checks if crop needs additional work on current sol.
	 * 
	 * @return true if more work needed.
	 */
	public boolean requiresWork() {
		if (phaseType == PhaseType.HARVESTING)
			return true;
		else {
			Phase active = cropSpec.getPhase(phaseType);
			if (active != null) {
				return active.getWorkRequired() * 1000D >= currentPhaseWorkCompleted;
			}
		}
		return false;
	}


	/**
	 * Tracks the overall health condition of the crop.
	 * @return condition as value from 0 (poor) to 1 (healthy)
	 */
	private double trackHealth() {
		// 0:bad, 1:good
		double health = 0D;
		
		switch(phaseType) {
		case INCUBATION:
		case PLANTING:
			health = 1D;
			break;
			
		case GERMINATION:
			if (percentageGrowth <= 5D) {
				// avoid initial spurious data at the start of the sim
				health = 1D;
			}
			else {
				health = calculateHealth();
			}
			break;
			
		default:
			health = calculateHealth();
			break;
		}

		if (health > 1D)
			health = 1D;
		else if (health < 0D)
			health = 0D;

		if (percentageGrowth > 10D) {
			// Check on the health of a >10% growing crop
			if (health < .05) {
				logger.log(building, Level.WARNING, 0, "Crop " + cropSpec.getName() 
						+ " died of very poor health (" + Math.round(health * 100D) / 100D + " %)");
				// Add Crop Waste
				double amt = (percentageGrowth * remainingHarvest * RandomUtil.getRandomDouble(.5))/100D;
				if (amt > 0) {
					store(amt, CROP_WASTE_ID, "Crop::trackHealth");
					logger.log(building, Level.WARNING, 0, amt + " kg Crop Waste generated from the dead " + cropSpec.getName());
				}
				phaseType = PhaseType.FINISHED;
			}
		}

		else { // fractionalGrowthCompleted < .1 && fractionalGrowthCompleted > 0D
				// Seedling (<10% grown crop) is less resilient and more prone to environmental
				// factors
			if (health < .2) {
				logger.log(building, Level.WARNING, 0, "The seedlings of " + cropSpec.getName() + " had poor health ("
						+ Math.round(health * 100D) / 100D + " %) and didn't survive.");
				// Add Crop Waste
				double amt = (percentageGrowth * remainingHarvest * RandomUtil.getRandomDouble(.5))/100D;
				if (amt > 0) {
					store(amt, CROP_WASTE_ID, "Crop::trackHealth");
					logger.log(building, Level.WARNING, 0, amt + " kg Crop Waste generated from the dead " + cropSpec.getName());
				}
				phaseType = PhaseType.FINISHED;
			}
		}

		// set healthCondition so that it can be accessed outside of this class
		healthCondition = health;

		return health;
	}

	/*
	 * Computes the health of a crop
	 */
	private double calculateHealth() {
		double health = 0;
		double total = 0;
		int size = environmentalFactor.length;
		for (int i=0; i< size; i++) {		
			if (cropSpec.getCropCategoryType() == CropCategoryType.FUNGI) {
				if (i == LIGHT_FACTOR)
					total = total + 1;
				else
					total = total + environmentalFactor[i];
			}
			
			else {
				total = total + environmentalFactor[i];
			}
		}
		
		// TODO: will need to model diseaseIndex
		health = (1 - diseaseIndex) * total / size;
		
		if (health > 1)
			health = 1;
		
		return health;
	}

	/**
	 * Adds work time to the crops current phase.
	 * 
	 * @param workTime - Work time to be added (millisols)
	 * @return workTime remaining after working on crop (millisols)
	 * @throws Exception if error adding work.
	 */
	public double addWork(Worker worker, double workTime) {
		// Called by Farming's addWork()
		double remainingTime = 0;
		// Note: it's important to set remainingTime initially to zero. If not, addWork will be in endless while loop
		String name = cropSpec.getName();

		// Improve the health of the crop each time it's being worked on
		if (healthCondition < 1)
			healthCondition += .001 * workTime;
		if (healthCondition > 1)
			healthCondition = 1;
		
		Phase currentPhase = cropSpec.getPhase(phaseType);
		double w = currentPhase.getWorkRequired() * 1000D;

		if (dailyHarvest < 0D) {
			dailyHarvest = 0;
			growingTimeCompleted = 0;
		}

		// Only do phases that need manual work
		switch (phaseType) {
		case INCUBATION:
		case PLANTING:
			// at a particular growing phase (NOT including the harvesting phase)
			currentPhaseWorkCompleted += workTime;

			if (currentPhaseWorkCompleted >= w * 1.01) {
				remainingTime = currentPhaseWorkCompleted - w;
				currentPhaseWorkCompleted = 0D;
				phaseType = cropSpec.getNextPhaseType(phaseType);
				logger.log(building, Level.FINE, 0, name + " had entered a new phase " + phaseType
						+ "   Work Completed : " + Math.round(currentPhaseWorkCompleted * 10D) / 10D
						+ "   Work Required : " + Math.round(w * 10D) / 10D);
			}
			break;

		case MATURATION:
		case HARVESTING:
			// at the maturation or harvesting phase
			currentPhaseWorkCompleted += workTime;
			// Set the harvest multiplier
			int multiplier = 5;
			
			if (currentPhaseWorkCompleted >= w * 1.01) {
				// Modify parameter list to include crop name
				double lastHarvest = multiplier * dailyHarvest * workTime / w;

				if (remainingHarvest > 0) {
					collectProduce(lastHarvest);

					remainingHarvest -= lastHarvest;					
					totalHarvest += lastHarvest;
					
					remainingTime = Math.min(workTime, currentPhaseWorkCompleted - w);

					// Don't end until there is nothing left ?
					if (remainingHarvest <= 0) {
						logger.log(building, worker, Level.INFO, 0, "Harvested a total of "
									+ Math.round(totalHarvest * 100.0) / 100.0 + " kg "
									+ name + ".", null);
						
						if (phaseType == PhaseType.MATURATION)
							logger.log(building, worker, Level.INFO, 0, "Closed out the initial harvest of " 
									+ name + ".", null);
	
						else if (phaseType == PhaseType.HARVESTING)
							logger.log(building, worker, Level.INFO, 0, "Closed out the final harvest of " 
									+ name + ".", null);
						
						// Reset the totalHarvest back to zero.
						totalHarvest = 0;
						// Sets the phase to FINISHED
						phaseType = PhaseType.FINISHED;
						
						//  Check to see if a botany lab is available
						if (worker instanceof Person && !farm.checkBotanyLab(cropSpec, worker))
							logger.log(building, worker, Level.INFO, 0, 
									"Can't find an available lab bench to work on the tissue culture for " 
											+ name + ".", null);
					}
				}
			}
			else {
				if (dailyHarvest > 0.00001) {
					// Continue the harvesting process
					double modifiedHarvest = multiplier * dailyHarvest * workTime / w;
					// Store the crop harvest
					if (modifiedHarvest > 0 && remainingHarvest > 0) {
						collectProduce(modifiedHarvest);
						remainingHarvest -= modifiedHarvest;
						totalHarvest += modifiedHarvest;
					}
					remainingTime = 0D;
				}
			}
			break;
	
		case FINISHED:
			// Shouldn;t be here
			break;
		
		default:
			// at a particular growing phase (NOT including the harvesting phase)
			currentPhaseWorkCompleted += workTime;

			if (currentPhaseWorkCompleted >= w * 1.01) {
				remainingTime = Math.min(workTime, currentPhaseWorkCompleted - w);
				currentPhaseWorkCompleted = 0D;
			}
			break;
		}

		// Safety check
		if ((phaseType == PhaseType.HARVESTING) && percentageGrowth > 115D)  {
			logger.log(building, Level.FINE, 0, name + "'s fractionalGrowingTimeCompleted is " + percentageGrowth
					   + "%  Setting the phase to FINISHED.");
			phaseType = PhaseType.FINISHED;	
		}
	
		return remainingTime;
	}

	private void collectProduce(double harvestMass) {
		boolean isSeedPlant = cropSpec.isSeedPlant();
		int seedID = cropSpec.getSeedID();
		int cropID = cropSpec.getCropID();
		String source = "Crop::addWork";
		
		if (isSeedPlant) {
			// Extract Sesame Seed. 
			// Note the purpose for this plant is primarily the seeds 
			store(harvestMass, seedID, source);
		}
		else if ((seedID > 0) && harvestMass * massRatio > 0) {
			// White Mustard has leaves as food. Also extract Mustard Seed
			store(harvestMass * massRatio, seedID, source);
			store(harvestMass, cropID, source);
		}
		else {
			store(harvestMass, cropID, source);
		}

		// Calculate the amount of leaves and crop wastes that are generated
		double inedible = harvestMass / cropSpec.getEdibleBiomass() * cropSpec.getInedibleBiomass();
		double cropWaste = inedible * RATIO_LEAVES;
		if (cropWaste > 0) {
			store(cropWaste, CROP_WASTE_ID, "Crop::generateCropWaste");
		}
		
		if (cropSpec.getCropCategoryType() == CropCategoryType.LEAVES) {
			double leaves = inedible - cropWaste;
			if (leaves > 0) {
				store(leaves, ResourceUtil.leavesID, "Crop::generateCropWaste");
			}
		}
	}
	
	private void updateUsage(int currentSol) {
		String name = cropSpec.getName();
//		if (cumulative_water_usage > 0) {
			// Records the water usage per crop in the farm
			farm.addCropUsage(name, cumulative_water_usage, currentSol, 0);
			// Reset the water usage
			cumulative_water_usage = 0;
//		}

//		if (cumulative_o2 > 0) {
			// Records the CO2 consumption/generation in the farm
			farm.addCropUsage(name, cumulative_o2, currentSol, 1);
			// Reset the consumption/generation
			cumulative_o2 = 0;
//		}

//		if (cumulative_co2 > 0) {
			// Records the oxygen consumption/generation in the farm
			farm.addCropUsage(name, cumulative_co2, currentSol, 2);
			// Reset the consumption/generation
			cumulative_co2 = 0;
//		}
	}
	
	/**
	 * Time passing for crop.
	 * @param solarIrradiance 
	 * @param greyFilterRate 
	 * @param temperatureModifier 
	 * 
	 * @param time - amount of time passing (millisols)
	 */
	public boolean timePassing(ClockPulse pulse, double productionLevel,
							   double solarIrradiance, double greyFilterRate,
							   double temperatureModifier) {

		if (phaseType == PhaseType.FINISHED) {
			return true;
		}
		double time = pulse.getElapsed() * productionLevel;

		growingTimeCompleted += time;
		percentageGrowth = (growingTimeCompleted * 100D) / cropSpec.getGrowingTime();
					
		if (phaseType != PhaseType.HARVESTING) {
			// Right before the harvesting phase
			if (percentageGrowth > cropSpec.getNextPhasePercentage(phaseType)) {
				// Advance onto the next phase
				phaseType = cropSpec.getNextPhaseType(phaseType);
			}
		}

		// check for the passing of each day
		if (pulse.isNewSol()) {
			
			// Resets the daily harvest back to zero
			dailyHarvest = 0;
			
			// Update the resource usage
			updateUsage(pulse.getMarsTime().getMissionSol());

			if (dailyHarvest < 0) {
				phaseType = PhaseType.FINISHED;
				dailyHarvest = 0;
				return true;
			}
			// Note: is it better off doing the actualHarvest computation once a day or
			// every time
			// Reset the daily work counter currentPhaseWorkCompleted back to zero
			// currentPhaseWorkCompleted = 0D;
			cumulativeDailyPAR = 0;
		}

		int msol = pulse.getMarsTime().getMillisolInt();
		if (msol % CHECK_HEALTH_FREQUENCY == 0) {
			// Checks on crop health
			trackHealth();
		}

		// max possible harvest within this period of time
		double maxPeriodHarvest = maxHarvest * (time / cropSpec.getGrowingTime());
		// Compute each harvestModifiers and sum them up below
		// Note: computeHarvest takes up 40% of all cpu utilization
		double harvestModifier = computeHarvest(maxPeriodHarvest, pulse, time,
												solarIrradiance,
												greyFilterRate,
												temperatureModifier);
		// Add to the daily harvest.
		dailyHarvest += maxPeriodHarvest * harvestModifier;
		// Add to the cumulative harvest.				
		remainingHarvest += maxPeriodHarvest * harvestModifier;
		
		if ((dailyHarvest < 0) || (percentageGrowth > 110D)) {
			phaseType = PhaseType.FINISHED;
		}

		if (phaseType == PhaseType.FINISHED) {
			dailyHarvest = 0;
			totalHarvest = 0;
		}
		return true;
	}

	private void turnOnLighting(double kW) {
		lightingPower = kW;
	}

	private void turnOffLighting() {
		lightingPower = 0;
	}

	/**
	 * Computes the effects of the available sunlight and artificial light
	 * 
	 * @param time
	 * @param solarIrradiance 
	 * @return instantaneous PAR or uPAR
	 */
	private double computeLight(ClockPulse pulse, double time, double solarIrradiance) {
		double lightModifier = 0;

		int msols = pulse.getMarsTime().getMillisolInt();
		// Note : The average PAR is estimated to be 20.8 mol/(mÂ² day) (Gertner, 1999)
		// Calculate instantaneous PAR from solar irradiance
		double uPAR = wattToPhotonConversionRatio * solarIrradiance;
		// [umol /m^2 /s] = [u mol /m^2 /s /(Wm^-2)] * [Wm^-2]
		double PAR_interval = uPAR / 1_000_000D * time * MarsClock.SECONDS_PER_MILLISOL; // in mol / m^2 within this
		
		double dailyPARRequired = cropSpec.getDailyPAR();
		// period of time
		// [mol /m^2] = [umol /m^2 /s] / u * [millisols] * [s /millisols]
		// 1 u = 1 micro = 1/1_000_000
		// Note : daily-PAR has the unit of [mol /m^2 /day]
		// Gauge if there is enough sunlight
		double progress = cumulativeDailyPAR / dailyPARRequired; // [max is 1]

		double clock = msols / 1000D; // [max is 1]

		// When enough PAR have been administered to the crop, the HPS_LAMP will turn
		// off.
		// TODO: what if the time zone of a settlement causes sunlight to shine at near
		// the tail end of the currentMillisols time ?
		// Compared cumulativeDailyPAR / dailyPARRequired vs. current time /
		// 1000D
		// Reduce the frequent toggling on and off of lamp and to check on
		// the time of day to anticipate the need of sunlight.
		if (0.5 * progress < clock && msols <= 333 || 0.7 * progress < clock && msols > 333 && msols <= 666
				|| progress < clock && msols > 666) {
			// TODO: also compare also how much more sunlight will still be available
			if (uPAR > 40) { // if sunlight is available
				turnOffLighting();
				cumulativeDailyPAR = cumulativeDailyPAR + PAR_interval;
				// Gets the effectivePAR
				effectivePAR = PAR_interval;	 
			}

			else { // if no sunlight, turn on artificial lighting
					// double conversion_factor = 1000D * wattToPhotonConversionRatio /
					// MarsClock.SECONDS_IN_MILLISOL ;
					// DLI is Daily Light Integral is the unit for for cumulative light -- the
					// accumulation of all the PAR received during a day.
				double DLI = dailyPARRequired - cumulativeDailyPAR; // [in mol / m^2 / day]
				double delta_PAR_outstanding = DLI * (time / 1000D) * growingArea;
				// in mol needed at this delta time [mol] = [mol /m^2 /day] * [millisol] /
				// [millisols /day] * m^2
				double delta_kW = delta_PAR_outstanding / time / conversion_factor;
				// [kW] = [mol] / [u mol /m^2 /s /(Wm^-2)] / [millisols] / [s /millisols] = [W
				// /u] * u * k/10e-3 = [kW]; since 1 u = 10e-6
				// TODO: Typically, 5 lamps per square meter for a level of ~1000 mol/ m^2 /s
				// Added PHYSIOLOGICAL_LIMIT sets a realistic limit for tuning how
				// much PAR a food crop can absorb per frame.
				// Note 1 : PHYSIOLOGICAL_LIMIT minimize too many lights turned on and off too
				// frequently
				// Note 2 : It serves to smooth out the instantaneous power demand over a period
				// of time
				// each HPS_LAMP lamp supplies 400W has only 40% visible radiation efficiency
				int numLamp = (int) (Math.ceil(
						delta_kW / KW_PER_HPS / VISIBLE_RADIATION_HPS / (1 - BALLAST_LOSS_HPS) * PHYSIOLOGICAL_LIMIT));
				// TODO: should also allow the use of LED_KIT for lighting
				// For converting lumens to PAR/PPF, see
				// http://www.thctalk.com/cannabis-forum/showthread.php?55580-Converting-lumens-to-PAR-PPF
				// Note: do NOT include any losses below
				double supplykW = numLamp * KW_PER_HPS * VISIBLE_RADIATION_HPS * (1 - BALLAST_LOSS_HPS)
						/ PHYSIOLOGICAL_LIMIT;
				turnOnLighting(supplykW);
				double delta_PAR_supplied = supplykW * time * conversion_factor / growingArea; // in mol / m2
				// [ mol / m^2] = [kW] * [u mol /m^2 /s /(Wm^-2)] * [millisols] * [s /millisols]
				// / [m^2] = k u mol / W / m^2 * (10e-3 / u / k) = [mol / m^-2]
				cumulativeDailyPAR = cumulativeDailyPAR + delta_PAR_supplied + PAR_interval;
				// [mol /m^2 /d]
				
				// Gets the effectivePAR
				effectivePAR = delta_PAR_supplied + PAR_interval;				 
			}
		}

		else {
			turnOffLighting();
		}

		// check for the passing of each day
		int newSol = pulse.getMarsTime().getMissionSol();
		// the crop has memory of the past lighting condition
		lightModifier = cumulativeDailyPAR / (dailyPARRequired + .0001) * 1000D / ( msols  + .0001);
		// TODO: If too much light, the crop's health may suffer unless a person comes
		// to intervene
		if (isStartup && newSol == 1) {
			// if this crop is generated at the start of the sim, 
			// lightModifier should start from 1, rather than 0
			lightModifier = 1;
		}
		
		adjustEnvironmentFactor(lightModifier, LIGHT_FACTOR);

		return uPAR;

	}


	/***
	 * Computes the effect of water and fertilizer
	 * 
	 * @param needFactor
	 * @param time
	 * @param greyFilterRate 
	 */
	private void computeWaterFertilizer(double needFactor, double time, double greyFilterRate) {
		// Calculate water usage kg per sol
		double waterRequired =  TUNING_FACTOR * needFactor * (averageWaterNeeded * time / 1_000D) * growingArea; // fractionalGrowingTimeCompleted
		// Determine the amount of grey water available.
		double gw = building.getSettlement().getAmountResourceStored(GREY_WATER_ID);
		double greyWaterAvailable = Math.min(gw * greyFilterRate * time, gw);
		double waterUsed = 0;
		double greyWaterUsed = 0;


		double waterModifier = 0;
		double fertilizerModifier = 0;

		// First water crops with grey water if it is available.
		if (greyWaterAvailable >= waterRequired) {
			greyWaterUsed = waterRequired;

			if (greyWaterUsed > MIN)
				retrieve(greyWaterUsed, GREY_WATER_ID, true);
			// TODO: track grey water as well ?
			waterModifier = 1D;
		}

		else if (greyWaterAvailable < waterRequired) {
			// If not enough grey water, use water
			greyWaterUsed = greyWaterAvailable;
			if (greyWaterUsed > MIN)
				retrieve(greyWaterUsed, GREY_WATER_ID, true);
			// TODO: track grey water as well ?
			waterRequired = waterRequired - greyWaterUsed;
			double waterAvailable = building.getSettlement().getAmountResourceStored(WATER_ID);
			
			if (waterAvailable >= waterRequired) {
				waterUsed = waterRequired;
				if (waterUsed > MIN) {
					retrieve(waterUsed, WATER_ID, true);
					//  Records the daily water usage in the farm
					farm.addDailyWaterUsage(waterUsed);
				}
				
				waterModifier = 1D;
			}
			else {
				// not enough water
				waterUsed = waterAvailable;
				if (waterUsed > MIN) {
					retrieve(waterUsed, WATER_ID, true);
					//  Records the daily water usage in the farm
					farm.addDailyWaterUsage(waterUsed);
				}
				// Incur penalty if water is NOT available
				// need to add .0001 in case waterRequired becomes zero
				waterModifier = (greyWaterUsed + waterUsed) / (waterRequired + .0001);
			}

			double fertilizerAvailable = building.getSettlement().getAmountResourceStored(FERTILIZER_ID);
			// The amount of fertilizer to be used depends on the ratio of the grey water used
			double fertilizerRequired = FERTILIZER_NEEDED_WATERING * time * greyWaterUsed / (greyWaterUsed + waterUsed + .0001);
			double fertilizerUsed = fertilizerRequired;

			if (fertilizerUsed > fertilizerAvailable) {
				// not enough fertilizer
				fertilizerUsed = fertilizerAvailable;
				// should incur penalty due to insufficient fertilizer
				fertilizerModifier = fertilizerUsed / ( fertilizerRequired + 0.0001);
			} else {
				// there's enough fertilizer
				fertilizerModifier = 1D;
			}

			if (fertilizerUsed > MIN) {
				retrieve(fertilizerUsed, FERTILIZER_ID, true);
			}

			adjustEnvironmentFactor(fertilizerModifier, FERTILIZER_FACTOR);

		}

		// Amount of water reclaimed through a Moisture Harvesting System inside the
		// Greenhouse
		// TODO: Modify harvest modifier according to the moisture level
		// double waterReclaimed = totalWaterUsed * growingArea * time / 1000D *
		// MOISTURE_RECLAMATION_FRACTION;
		// if (waterReclaimed > 0)
		// Storage.storeAnResource(waterReclaimed, waterID, inv, sourceName +
		// "::computeWaterFertilizer");

		// Assume an universal rate of water vapor evaporation rate of 5%
		// farm.addMoisture(totalWaterUsed*.05);
		// Record the amount of water taken up by the crop
		cumulative_water_usage = cumulative_water_usage + waterUsed;// * .95;

		adjustEnvironmentFactor(waterModifier, WATER_FACTOR);

	}

	/***
	 * Computes the effects of the concentration of O2 and CO2
	 * 
	 * @param uPAR
	 * @param needFactor
	 * @param maxPeriodHarvest
	 * @param time
	 */
	private void computeGases(double uPAR, double needFactor, double time) {
		double watt = uPAR / time / conversion_factor * growingArea * 1000; 

		// Note: uPAR includes both sunlight and artificial light
		// Calculate O2 and CO2 usage kg per sol
		double o2Modifier = 0, co2Modifier = 0;
		double fudge_factor = 0;

		if (watt < 40) {
//			if (uPAR == 0)
				fudge_factor = 2.5;
//			else if (uPAR == 40)
//				fudge_factor = 2.5;
//			else
//				fudge_factor = 5 - 2.5 * uPAR / 40;
//			
//			if (fudge_factor < 0)
//				fudge_factor = 0;
			
			double o2Required = (percentageGrowth * fudge_factor * needFactor / 100D)
					* (averageOxygenNeeded * time / 1000) * growingArea;
			double o2Available = building.getSettlement().getAmountResourceStored(OXYGEN_ID);
			double o2Used = o2Required;

			o2Modifier = o2Available / o2Required;

			if (o2Used > o2Available)
				o2Used = o2Available;
			if (o2Used > MIN) {
				retrieveO2(o2Used);
				cumulative_o2 = cumulative_o2 - o2Used;
			}

			adjustEnvironmentFactor(o2Modifier, O2_FACTOR);

			// Determine the amount of co2 generated via gas exchange.
			double cO2Gen = o2Used * CO2_TO_O2_RATIO;
			if (cO2Gen > MIN) {
				storeCO2(cO2Gen);
				// farm.addCO2Cache(cO2Gen);
				cumulative_co2 = cumulative_co2 + cO2Gen;
			}
		}

		else {
			// during the day
			fudge_factor = .0185 * watt + 1.76;
			// TODO: gives a better modeling of how the amount of light available will
			// trigger photosynthesis that converts co2 to o2
			// Determine harvest modifier by amount of carbon dioxide available.
			double cO2Req = (percentageGrowth * fudge_factor * needFactor / 100D)
					* (averageCarbonDioxideNeeded * time / 1000) * growingArea;
			double cO2Available = building.getSettlement().getAmountResourceStored(CO2_ID);
			double cO2Used = cO2Req;

			// TODO: allow higher concentration of co2 to be pumped to increase the harvest
			// modifier to the harvest.

			co2Modifier = cO2Available / cO2Req;
			
			if (cO2Used > cO2Available)
				cO2Used = cO2Available;
			if (cO2Used > MIN) {
				retrieveCO2(cO2Used);
				cumulative_co2 = cumulative_co2 - cO2Used;
			}
			// Note: research how much high amount of CO2 may facilitate the crop growth and
			// reverse past bad health
			
			adjustEnvironmentFactor(co2Modifier, CO2_FACTOR);

			// 6CO2 + 6H2O + sunlight -> C6H12O6 + 6O2
			//
			// Determine the amount of oxygen generated during the day when photosynthesis
			// is taking place .
			double o2Gen = cO2Used * O2_TO_CO2_RATIO;
			if (o2Gen > 0) {
				storeO2(o2Gen);
				cumulative_o2 = cumulative_o2 + o2Gen;
			}
		}
	}

	/**
	 * Adjust the environmental factors
	 * 
	 * @param mod the modifier of interest
	 * @param type the 
	 */
	private void adjustEnvironmentFactor(double mod, int type) {
		double f = environmentalFactor[type];
		f = 0.01 * mod + 0.99 * f;
		if (f > 1.25)
			f = 1.25;	
		else if (f < 0.1 || Double.isNaN(f))
			f = 0.1;
		environmentalFactor[type] = f;
	}
	
	/**
	 * Computes each input and output constituent for a crop for the specified
	 * period of time and return the overall harvest modifier
	 * @param solarIrradiance 
	 * @param greyFilterRate 
	 * @param temperatureModifier 
	 * @param the maximum possible growth/harvest
	 * @param a   period of time in millisols
	 * @return the harvest modifier
	 */
	private double computeHarvest(double maxPeriodHarvest, ClockPulse pulse,
						double time, double solarIrradiance, double greyFilterRate,
						double temperatureModifier) {

		double harvestModifier = 1D;

		// TODO: use theoretical model for crop growth, instead of empirical model
		// below.
		// TODO: the calculation should be uniquely tuned to each crop
		// TODO: Modify harvest modifier according to the pollination by the number of
		// bees in the greenhouse
		// TODO: Modify harvest modifier by amount of artificial light available to the
		// whole greenhouse

		// Tune the growthFactor according to the stage of a crop
		double growthFactor = 5;
		// amount of grey water/water needed is also based on % of growth
		if (phaseType == PhaseType.GERMINATION)
			// if (phaseType == PhaseType.GERMINATION)
			growthFactor = .2;
		else if (percentageGrowth < 10D)
			growthFactor = .3;
		else if (percentageGrowth < 15D)
			growthFactor = .4;
		else if (percentageGrowth < 20D)
			growthFactor = .5;
		else if (phaseType == PhaseType.FINISHED)
			growthFactor = .4;
		else if ((phaseType != PhaseType.HARVESTING) && (phaseType != PhaseType.PLANTING))
			growthFactor = percentageGrowth/100D;


		// STEP 1 : COMPUTE THE EFFECTS OF THE SUNLIGHT AND ARTIFICIAL LIGHT
		if (cropSpec.getCropCategoryType() == CropCategoryType.FUNGI) {
			adjustEnvironmentFactor(1D, LIGHT_FACTOR);
		}
		else {
			computeLight(pulse, time, solarIrradiance);
		}
		
		// STEP 2 : COMPUTE THE EFFECTS OF THE TEMPERATURE
		adjustEnvironmentFactor(temperatureModifier, TEMPERATURE_FACTOR);

		// STEP 3 : COMPUTE THE EFFECTS OF THE WATER AND FERTIZILER
		computeWaterFertilizer(growthFactor, time, greyFilterRate);

		// STEP 4 : COMPUTE THE EFFECTS OF GASES (O2 and CO2 USAGE)
		// Note: computeGases takes up 25% of all cpu utilization
		computeGases(effectivePAR, growthFactor, time);
		// Note that mushrooms are fungi and consume O2 and release CO2

		// TODO: add air pressure modifier in future

		// Tune harvestModifier
		// Note that light is the dorminant environmental factor
		if (phaseType == PhaseType.GERMINATION) {
			harvestModifier = .8 * harvestModifier + .2 * harvestModifier * environmentalFactor[LIGHT_FACTOR];
		}
		else if ((phaseType != PhaseType.PLANTING) && (phaseType != PhaseType.INCUBATION)) {
			harvestModifier = .6 * harvestModifier + .4 * harvestModifier * environmentalFactor[LIGHT_FACTOR];
		}
		
		harvestModifier = .25 * harvestModifier + .15 * harvestModifier * environmentalFactor[FERTILIZER_FACTOR]
						+ .15 * harvestModifier * environmentalFactor[TEMPERATURE_FACTOR]
						+ .15 * harvestModifier * environmentalFactor[WATER_FACTOR]
						+ .15 * harvestModifier * environmentalFactor[O2_FACTOR]
						+ .15 * harvestModifier * environmentalFactor[CO2_FACTOR];

		// TODO: research how the above 6 factors may affect crop growth for different
		// crop categories

		return harvestModifier;
	}
	
	public void resetPAR() {
		cumulativeDailyPAR = 0;
	}

	public double getHealthCondition() {
		return healthCondition;
	}

	public double getPercentGrowth() {
		return  Math.round(percentageGrowth * 10D)/10D;
	}

	public int getIdentifier() {
		return identifier;
	}
	
	/**
	 * Retrieve the carbon dioxide
	 * 
	 * @param amount
	 * @return
	 */
	private boolean retrieveCO2(double amount) {
		boolean result = false;
		if (co2Cache - amount < -co2Threshold) {
			result = retrieve(co2Cache, CO2_ID, true);
			co2Cache = -amount;
		}
		else {
			co2Cache -= amount;
		}
		return result;
	}
	
	/**
	 * Retrieve the oxygen 
	 * 
	 * @param amount
	 * @return
	 */
	private boolean retrieveO2(double amount) {
		boolean result = false;
		if (o2Cache - amount < -o2Threshold) {
			result = retrieve(o2Cache, OXYGEN_ID, true);
			o2Cache = -amount;
		}
		else {
			o2Cache -= amount;
		}
		return result;
	}
	
	/**
	 * Retrieves the amount resource
	 * 
	 * @param amount
	 * @param resource
	 * @param value
	 * @return
	 */
	private boolean retrieve(double amount, int resource, boolean value) {
		if (building.getSettlement().retrieveAmountResource(resource, amount) == 0)
			return true;
		return false;
	}
	
	/**
	 * Stores the carbon dioxide
	 * 
	 * @param amount
	 * @return
	 */
	private boolean storeCO2(double amount) {
		boolean result = false;
		if (co2Cache + amount > co2Threshold) {
			result = store(co2Cache, CO2_ID, "Crop::computeGases");
			co2Cache = amount;
		}
		else {
			co2Cache -= amount;
		}
		return result;
	}

	/**
	 * Stores the oxygen
	 * 
	 * @param amount
	 * @return
	 */
	private boolean storeO2(double amount) {
		boolean result = false;
		if (o2Cache + amount > o2Threshold) {
			result = store(o2Cache, OXYGEN_ID, "Crop::computeGases");
			o2Cache = amount;
		}
		else {
			o2Cache -= amount;
		}
		return result;
	}
	
	/**
	 * Stores the amount resource
	 * 
	 * @param amount
	 * @param resource
	 * @param source
	 * @return
	 */
	private boolean store(double amount, int resource, String source) {
		if (building.getSettlement().storeAmountResource(resource, amount) == 0)
			return true;
		return false;
	}
	

	/**
	 * Crop need power in any phase that is not the first or last
	 * @return
	 */
	public boolean needsPower() {
		return (phaseType != PhaseType.INCUBATION) && (phaseType != PhaseType.FINISHED);
	}
	
	/**
	 * Compares if the object is the same as this crop
	 */
	@Override
	public boolean equals(Object obj) {
		if (this == obj) return true;
		if (obj == null) return false;
		if (this.getClass() != obj.getClass()) return false;
		Crop c = (Crop) obj;
		return this.identifier == c.getIdentifier();
	}

	@Override
	public int hashCode() {
		return identifier % 32;
	}
	
	/**
	 * Reloads instances after loading from a saved sim
	 * @param cropConfig2 
	 * 
	 * @param {@link MasterClock}
	 * @param {{@link MarsClock}
	 */
	public static void initializeInstances(CropConfig cropConfig2) {
		cropConfig = cropConfig2;
	}

	@Override
	public String toString() {
		return "Crop [name=" + cropSpec.getName() + " @ " + building + "]";
	}

	@Override
	public int compareTo(Crop o) {
		return cropSpec.compareTo(o.getCropType());
	}
}
